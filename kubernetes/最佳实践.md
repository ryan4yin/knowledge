# Kubernetes 最佳实践


1. 安全：参见 <security/README.md>
1. 调度策略：设置 Pod 反亲和以实现 Pod 的均匀分布、设置资源请求与限制、设置 HPA


## 优雅停止（Gracful Shutdown）与 502/504 报错

如果 Pod 正在处理大量请求（比如 1000 QPS+）时，因为节点故障或「竞价节点」被回收等原因被重新调度，
你可能会观察到在容器被 terminate 的一段时间内出现少量 502/504，这是因为被发送到 Pod 的请求还没有被处理完，Pod 就已经死掉了导致的。

为了搞清楚这个问题，需要先理解清楚 terminate 一个 Pod 的流程：

1. Pod 的状态被设为「Terminating」，（几乎）同时该 Pod 被从所有关联的 Service Endpoints 中移除
2. `preStop` 钩子被执行，它可以是一个命令，或者一个对 Pod 中容器的 http 调用
   1. 如果你的程序在收到 SIGTERM 信号时，无法优雅退出，就可以考虑使用 `preStop`
   2. 如果让程序本身支持优雅退出比较麻烦的话，用 `preStop` 实现优雅退出是一个非常好的方式
3. 将 SIGTERM 发送给 Pod 中的所有容器
4. 继续等待，直到超过 `spec.terminationGracePeriodSeconds` 设定好的时间，这个值默认为 30s
   1. 需要注意的是，这个优雅退出的等待计时是与 `preStop` 同步开始的！而且它也不会等待 `preStop` 结束！
5. 如果超过了 `spec.terminationGracePeriodSeconds` 容器仍然没有停止，k8s 将会发送 SIGKILL 信号给容器
6. 进程全部终止后，整个 Pod 完全被清理掉

**注意**：1 和 2 两个工作是异步发生的，所以可能会出现「Pod 还在 Service Endpoints 中，但是 `preStop` 已经执行了」的情况，我们需要考虑到这种状况的发生。

了解了上面的流程后，我们就知道了，通常的解决方案是，在 Pod 的 `preStop` 步骤加一个 15s/30s 的等待时间。
其原理是：在 Pod 处理 terminating 状态的时候，就会被从 Service Endpoints 中移除，也就不会再有新的请求过来了。
在 `preStop` 等待 15s/30s，基本就能保证所有的请求都在容器死掉之前被处理完成（一般来说，绝大部分请求的处理时间都在 300ms 以内吧）。

一个简单的示例如下，它使 Pod 被终止时，总是先等待 30s，再发送 SIGTERM 信号给容器：

```yaml
lifecycle:
  preStop:
    exec:
      command:
      - /bin/sleep
      - "30"
```


## 参考

- [Kubernetes best practices: terminating with grace](https://cloud.google.com/blog/products/containers-kubernetes/kubernetes-best-practices-terminating-with-grace)
- [Graceful shutdown in Kubernetes is not always trivial](https://medium.com/flant-com/kubernetes-graceful-shutdown-nginx-php-fpm-d5ab266963c2)
